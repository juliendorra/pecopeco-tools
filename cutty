#!/bin/bash -e

KEEPDB=cuts_to_keep
REMOTE_PATH=storage/self/primary/Android/data/am.benth.pecopeco/files
files="puzzledb.json cutdb.json cuts"

usage() {
  name=$(basename $0)
  echo "usage : ${name} [clean|import|export|pull|push] [arg]"
  echo "        ${name} clean : keep only cuts listed in $KEEPDB"
  echo "        ${name} export <cutid>: export cut to a package"
  echo "        ${name} import <package.json>: import cut from a package "
  echo "        ${name} push: upload database to headset "
  echo "        ${name} pull: download database from headset "
  echo "        ${name} remove <cutid>: remove cut"
  echo "        ${name} list: list all cuts"
}

_getid() {
  prefix=$1
  jq -r --arg prefix $prefix '.puzzleInfos[] | select(.cutId | test("^"+$prefix)) | .cutId ' cache/puzzledb.json
}

_getmodelid() {
  prefix=$1
  jq -r --arg prefix $prefix '.puzzleInfos[] | select(.cutId | test("^"+$prefix)) | .modelId ' cache/puzzledb.json
}

lookup() {
  prefix=$1
  inpuzzledb=$(jq --arg prefix $prefix '[.puzzleInfos[] | select(.cutId | test("^"+$prefix))] | length' cache/puzzledb.json)
  incutdb=$(jq --arg prefix $prefix '[.cutInfos[] | select(.id | test("^"+$prefix))] | length' cache/cutdb.json)
  if compgen -G "cache/cuts/${prefix}*.json" > /dev/null ; then
    incutdir=$(ls cache/cuts/$prefix*.json | wc -l)
  else
    incutdir=0
  fi
  if [[ $inpuzzledb != $incutdb || $incutdb != $incutdir ]] ; then
    echo "Found $inpuzzledb in cache/puzzledb.json"
    echo "Found $incutdb in cache/cutdb.json"
    echo "Found $incutdir in cache/cuts/*"
    echo "Inconsistent data. Aborting."
    exit -1
  elif [[ $inpuzzledb == 1 ]] ; then
    echo "found"
  elif [[ $inpuzzledb == 0 ]] ; then
    echo "none"
  else
    echo "ambiguous"
  fi
}

list() {
  for cutid in $(getallcuts) ; do
    echo "$cutid ($(_getmodelid $cutid))"
  done
}

pull() {
  for file in $files ; do
    adb pull $REMOTE_PATH/$file cache/
  done
}

push() {
  adb shell rm -r $REMOTE_PATH/cuts/*

  for file in $files ; do
    adb push cache/$file $REMOTE_PATH
  done
}

getallcuts() {
(
  jq ".puzzleInfos[] .cutId" cache/puzzledb.json ;
  jq ".cutInfos[] .id" cache/cutdb.json ;
  find cache/cuts/ -name '*.json' -printf "%p\n" | cut -d. -f 1 | cut -d/ -f 3
  ) | \
    sed 's/"//g' | \
    sort | \
    uniq
}

remove() {
  prefix=$1
  if [[ $(lookup $prefix) == none ]] ; then
    echo "Found no cut with prefix ${prefix}."
    exit -1
  fi
  jq --arg prefix $prefix 'del (.puzzleInfos[] | select(.cutId | test("^"+$prefix)))' cache/puzzledb.json > puzzledb.json.updated && mv puzzledb.json.updated cache/puzzledb.json
  jq --arg prefix $prefix 'del (.cutInfos[] | select(.id | test("^"+$prefix)))' cache/cutdb.json > cutdb.json.updated && mv cutdb.json.updated cache/cutdb.json
  rm -f cache/cuts/$1*.json
}

whatshallIdowith() {
  result="drop"
  for pattern in $(cat $KEEPDB) ; do
    if  echo $1 | grep "^${pattern}" > /dev/null ; then
      result="keep"
    fi
  done
  echo -n $result
}

export_() {
  prefix=$1
  if [[ $(lookup $prefix) != unique ]] ; then
    echo "Can't find a single cut with prefix ${prefix} ($(lookup $prefix))"
    exit -1
  fi
  modelId="$(jq -r --arg prefix $prefix '.puzzleInfos[] | select(.cutId | test("^"+$prefix)) | .modelId ' cache/puzzledb.json )"
  packagefile="${modelId}-${prefix}.json"
  query='{ puzzleInfo: .[0].puzzleInfos[] | select(.cutId | test("^"+$prefix)) , cutInfo: .[1].cutInfos[] | select(.id | test("^"+$prefix)), slicers: .[2].slicers }'
  jq -s --arg prefix $prefix "$query" cache/puzzledb.json cache/cutdb.json cache/cuts/${prefix}*.json > $packagefile
  echo "Extracted $packagefile"
}

import () {
  packagefile=$1
  id=$(jq -r '.cutInfo .id' $packagefile)
  if [[ $(lookup $id) != none ]] ; then
    echo "This cut already exist : $id"
    exit -1
  fi
  cutfile=cache/cuts/$id.json
  jq '{slicers: .slicers}' $packagefile > $cutfile
  jq -s --arg id $id '.[0].puzzleInfos += [.[1].puzzleInfo] | .[0]' cache/puzzledb.json $packagefile > newpuzzledb.json && mv newpuzzledb.json cache/puzzledb.json
  jq -s --arg id $id '.[0].cutInfos += [.[1].cutInfo] | .[0]' cache/cutdb.json $packagefile > newcutdb.json && mv newcutdb.json cache/cutdb.json
}

clean() {
  if [[ ! -f $KEEPDB ]] ; then
    echo "List every cuts you want to keep in file '$KEEPDB'"
    exit -1
  fi
  echo "$(getallcuts | wc -l) cuts found"
  for cutid in $(getallcuts) ; do
    if [[ "$(whatshallIdowith $cutid)" == "drop" ]] ; then
      echo "Dropping $cutid â€¦"
      remove $cutid
    fi
  done
  echo "$(getallcuts | wc -l) cuts left"
}

case "$1" in
  pull)
    pull
    ;;
  push)
    push
    ;;
  clean)
    clean
    ;;
  list)
    list;
    ;;
  import)
    if [[ ! -f "$2" ]] ; then
      usage
      exit -1
    fi
    import $2
    ;;
  export)
    export_ $2
    ;;
  lookup)
    lookup $2
    ;;
  remove)
    remove $2
    ;;
  *)
    usage
esac
